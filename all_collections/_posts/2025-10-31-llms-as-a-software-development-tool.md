---
layout: post
title: LLMs as a software development tool
date: 2025-10-31
categories: ["software engineering", "LLM", "AI", "developer tools"]
---

LLMs can write code faster than me.

But they can't replace even a junior developer.

Here's why—and what that means for how we should actually use them:

## THE GOOD:

I constantly switch between Python, Scala, and Java. This used to mean endless context switching.

Googling syntax. Reading docs. StackOverflow rabbit holes.

Now? I just ask: "What's the idiomatic way to do X in language Y?"

Instant answer. Back to solving actual problems.

Game changer.

## THE DOWNSIDE:

LLMs will confidently write completely broken code. Delete critical data. Invent APIs that don't exist. Repeat the same function multiple times.

This is the core problem with "vibe coding"—developers generating code they don't understand and shipping it. There's a growing market of specialists cleaning up the mess.

That's not the future we want.

## MY APPROACH:

- Use LLMs for well-defined tasks
- Treat every suggestion as a first draft
- Code review AI output like it's from a junior dev

Here's the key insight: LLMs make mistakes no human would. Even the most inexperienced developer can think about implications for the end user or the business. LLMs can't.

The win isn't "AI writes my code."

The win is "AI handles boilerplate so I can focus on hard problems."

I work across Apache Storm, Spark, Solr, and various data stores. LLMs help me move between these platforms faster. But I never ship code I don't understand.

3 years ago, I thought LLMs would create subtle, hard-to-find bugs.

I was right. And they won't learn from mistakes, even when the guidance is right there in the context window.

But I was also wrong—because when used properly, they're a massive productivity boost.

The key word: properly.

What's your experience? Are LLMs helping or hurting your workflow?

#AI #SoftwareEngineering #LLM #DeveloperTools
